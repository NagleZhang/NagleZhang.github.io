---
title: "[Reading] 如何阅读《汇编语言》by 王爽"
subtitle: "「笔记」"
layout: post
author: "NagleZh"
header-style: text
lang: zh
tags:
  - 笔记
---

## 前言
本文试图回答下面几个问题：
1. 作为初学者是否适合,或者说拥有什么基础的人适合本书的阅读？
2. 那么本书应该如何阅读？
3. 本书阅读过程中可能存在的一些难点会是什么？
4. 解决上面问题的一些方式方法。

首先要回答的是，这本书是否适合初学者阅读？
答案是： 是的。什么程度？会用 Windows 操作系统，会下载程序即可；

紧接着，我们试图用更加系统的方式让你自己认知后面问题的答案。
阅读一本书，首先要明确一个问题，我阅读这本书的目的是什么? 这个可以说是阅读兴趣的源泉。  
或者说这个兴趣也也就是你阅读一本书的内驱力，失去这种驱动力，阅读索然无味。所以，阅读一本书的过程当中，最好是带着问题的问题的去去阅读的。  
那么对于所有需要阅读的书籍，首先的目的可以是：
1. 搞清楚作者想要讲什么？
2. 搞清楚作者是如何来进行规划他的表达思路的？ 

在提出上面两个问题之后，我们可以按照这种思路，快速的留恋一遍，从而形成我们对整本书的结构的理解。知道作者准备如何去表达自己的想法，输出自己的知识点。这个阅读的目的，也就是梳理整个书籍框架的过程。本文的主要内容也是对汇编语言梳理的结果。  

对书的整个梗概有了理解，我们就可以针对性的，对自己不能够理解的知识点，专门的去阅读，不同的数据开始有不同的阅读方式。这个就需要阅者本人去进行深入的探究，不在本文的输出范围。  

## 汇编语言--王爽 阅读总结

### 书籍架构梳理

《汇编语言》的理解可以分为几个部分
1. 基础知识： 这个是前四章的一个内容，会给初步学习过计算机的同学一个概念，以及几个后面实验可能需要用到的一些指令。这几个章节当中，从第二章开始，会用到一个叫做 debug 的基于 windows 的程序，辅助大家对一些基本的指令进行记忆，只要按照实验去做，就完全能够记得住。  
2. 实验分析：后面的一些系列章节，可以说是一步一个简单的实验，慢慢的将之前的所有指令进行慢慢揭晓的过程。可以想象一下，现在在你面前摆几百行的汇编程序，你完全没有概念应该如何开始阅读。而这本书的目的，就是将这个汇编程序里面设计到的指令，一种分成一章，带你练习，让你熟悉一个指令之后，再熟悉下一个指令。  
3. 实验分析的顺序：既然是一点点的讲解一个大的程序，那么一定是有先后的一个次序的。本书在汇编的这个指令的安排上，先后次序十分有讲究。可以这么说，大家理解一下冯诺依曼结构：读，取，控制，存储，运算；这五大结构。本书的次序是： 运算 -> 控制 -> 存储 -> 读/取  ，在第四章的时候，就可以依赖这个顺序能够完成一个比较小的程序。从第五章开始，书籍会一章引入一个（或者多个）控制的指令，让你在原有的程序上对该指令进行理解。

### 细节，各个章节的细节归属，以及为什么需要阅读这一章

#### 基础知识/寄存器/内存访问/第一个程序
这几个章节可以分为一个类，就是基础知识，阅读该四章之后，可以使用里面介绍的汇编语言完成一个小小的程序，并且理解链接，编译的一个简单过程。这个时候，基本上对汇编语言的执行过程有了一个基本的认识。  

#### [BX] 和 loop 指令/包含多个段的程序/更灵活的定位内存地址的方法/数据处理的两个基本问题

第六到九章，可以说是让我们拥有控制机器的能力，让我们更灵活的在内存当中进行定位，控制操作系统当中的多个段。  
一些重复性的指令，可以通过循环来控制；  

比如说，我们去获取一个数据，那么bit 位的数据是如何获取？我们需要使用到 【bx】加 loop 指令。  
系统当中有多个段的数据，我们的代码究竟放在什么位置？如何操作多个段的数据，介绍于第七章。  
大家都是效率为先，所以可以依赖更灵活的定位内存得方法，来进行寻址。  
关于数据处理的两个基本问题，原文已经给出： 
1. 如何找到数据？ 
2. 数据的长度有多少？
这样，你可以对数据拥有更强大的掌控能力。  

上面的这些东西完成之后，基本上对各个指令已经了然于心，可以写出一些过程化的汇编指令。

#### 转移指令的原理 为函数打地基 / CALL 和 RET 指令 函数 / 标志寄存器 if else

拥有基本的过程化的能力的基础上，我们可以把一些过程再抽象出来，形成模块化的东西。   
书籍的第十到十二章，就开始介绍模块化编程的基础。  
既然谈到模块化，那么模块化的指令很有可能是这里存一块，哪里存一块。  
所以第十章谈到了所谓转移指令的原理，jmp 指令，可以在指令之间腾转挪移，而不像纸空打片一样，按照指令一个一个的去执行。  
既然拥有了指令跳转的可能，书籍紧接着就开始了 call & ret 两个指令，实际上就是特殊的用来进行函数调用的 jmp 指令; 它的特殊性在于，支持参数（存放在栈里面）；  
而拥有了函数的调用支持之后，标志寄存器实际上就是用来进行判断，等同于高级语言当中的 if else 的功能。 在汇编语言当中，jmp 这条指令经常会应用该标志寄存器进行跳转，比如说 ja， 代表的是 jump if above，大于的情况下，就跳转，否则不跳转。等等这些功能；  


#### 内中断 / int 指令 / 端口 / 外中断 : OS Level
从十三章开始，其实就需要一定操作系统层面的知识来支撑了，否则可能会比较难理解这些指令存在的意义。  
中断，归纳在冯诺依曼结构当中，就是 I/O 层，也就是输入输出层。  
比如说键盘，你要输入，你按下键位的那一刻，会触发一些程序，这些程序是系统当中写好的，但是输入者不可能也不会等到 cpu 把需要密集运算的任务运算结束之后，该键位的程序再执行，那么，这个时候，触发键位的这个动作，也就是一个输入的中断操作。（在操作系统概论这本书里面，对这个的解释更加好，推荐阅读）  
而第十三章，内中断，int 指令（也就是中断指令），是针对内部程序的切换，比如说异常，多进程切换的操作的时候，需要用到。  
而外中断以及端口，则是针对硬件的一些操作 IO 时候，需要用到。  

#### 直接定址表 / 使用 BIOS 进行键盘输入和磁盘读写
一些技巧，以及实际操作

## 优势

本书的优势，第一点， 其知识点的隔离做的比较好。怎么理解这一块呢？ 打个比方来说，如果说你要学车，上来就给你讲一通汽车发动机的原理。这样子，大概率汽车是不能够被普及的。  
一般学车的经验是， 上来给你讲如何操作方向盘，如何踩油门，如何刹车等等。 这样，学会操作之后，提升起兴趣，再继续研究更多的东西。  
上面的一个例子，就是知识点隔离的一个很好的示范。本书也是这样，比如说在讲解寄存器的知识的时候，只是给你介绍寄存器的分类，然后直接让你上手操作。大大的降低了理解的难度。  
所以说，本书在这一点上，做的是我所读有限书籍里面做的最好的之一。  
第二，本书讲解的非常的细致，打个比方在介绍指令执行的这一节当中，它画出了每一步的 CPU 的寄存器的当前状态（当然是讲解过了的寄存器）,让你对寄存器的状态迁移有了一个完整的理解。  
    
## 缺点
说到优点，自然而然也会有缺点。本书的缺点就是，章节的本身就是为实验而服务的，所以很多时候，阅读过程当中，不知道为什么需要使用到某一条指令，这个指令的意义是什么，所以本书是需要一定的耐心去阅读的。


## 阅读建议
谈到本书的阅读需要一定的耐心程度，而且书籍章节的关联性很强，且汇编语言也并不是日常工作中会用到的语言。  
所以推荐的阅读建议是花两周的时间，冲刺性的阅读，读完第一到四章，然后不停去实践（Windows）书籍里面的实验。  
阅读的章节方面，第一章到第四章为一个部分，阅读完十二章以后，基本上会有很多中断的概念，而这个涉及到操作系统的一些知识的认知，仍然推荐去阅读一下《操作系统概论》，然后换着阅读，会对后面章节理解更加深入。
