---
title: "[Reading] 汇编语言 王爽 第三版总结"
subtitle: "「笔记」"
layout: post
author: "NagleZh"
header-style: text
lang: zh
tags:
  - 笔记
---

## 汇编语言--王爽 阅读总结

### 书籍架构梳理

本书可以分为几个部分
1. 基础知识： 这个是前四章的一个内容，会给初步学习过计算机的同学一个概念，以及几个后面实验可能需要用到的一些指令。这几个章节当中，从第二章开始，会用到一个叫做 debug 的基于 windows 的程序，辅助大家对一些基本的指令进行记忆，只要按照实验去做，就完全能够记得住。  
2. 实验分析：后面的一些系列章节，可以说是一步一个简单的实验，慢慢的将之前的所有指令进行慢慢揭晓的过程。可以想象一下，现在在你面前摆几百行的汇编程序，你完全没有概念应该如何开始阅读。而这本书的目的，就是将这个汇编程序里面设计到的指令，一种分成一章，带你练习，让你熟悉一个指令之后，再熟悉下一个指令。  
3. 实验分析的顺序：既然是一点点的讲解一个大的程序，那么一定是有先后的一个次序的。本书在汇编的这个指令的安排上，先后次序十分有讲究。可以这么说，大家理解一下冯诺依曼结构：读，取，控制，存储，运算；这五大结构。本书的次序是： 读/取 -> 运算 -> 控制，在第四章的时候，就可以依赖这个顺序能够完成一个比较小的程序。从第五章开始，书籍会一章引入一个（或者多个）控制的指令，让你在原有的程序上对该指令进行理解。

### 优势

本书的优势，第一点， 其知识点的隔离做的比较好。怎么理解这一块呢？ 打个比方来说，如果说你要学车，上来就给你讲一通汽车发动机的原理。这样子，大概率汽车是不能够被普及的。  
一般学车的经验是， 上来给你讲如何操作方向盘，如何踩油门，如何刹车等等。 这样，学会操作之后，提升起兴趣，再继续研究更多的东西。  
上面的一个例子，就是知识点隔离的一个很好的示范。本书也是这样，比如说在讲解寄存器的知识的时候，只是给你介绍寄存器的分类，然后直接让你上手操作。大大的降低了理解的难度。  
所以说，本书在这一点上，做的是我所读有限书籍里面做的最好的之一。  
第二，本书讲解的非常的细致，打个比方在介绍指令执行的这一节当中，它画出了每一步的 CPU 的寄存器的当前状态（当然是讲解过了的寄存器）,让你对寄存器的状态迁移有了一个完整的理解。  
    

### 细节，各个章节的细节归属，以及为什么需要阅读这一章

#### 基础知识/寄存器/内存访问/第一个程序
这几个章节可以分为一个类，就是基础知识，阅读该四章之后，可以使用里面介绍的汇编语言完成一个小小的程序，并且理解链接，编译的一个简单过程。这个时候，基本上对汇编语言的执行过程有了一个基本的认识。  


#### [BX] 和 loop 指令/包含多个段的程序/更灵活的定位内存地址的方法/数据处理的两个基本问题
如果说，上面的一个东西，是给我们取拧螺丝的时候提供了一个扁口的螺丝刀，那么，该章，就是在我们的工具箱里面添加了一个十字螺丝刀。让在汇编语言的编写过程。可以更加灵活。loop，就是相当于高级语言当中的 for 循环。[bx]，则相当于一个相对的地址, 比如说我现在的位置是北京市天安门，你是距离在我前面 10 米的位置,这里面的 bx，就是起 10 的这个作用。

在工具箱升级之后，我们需要拓宽我们工具箱的业务范围以及能力，可能之前我们只是接安装一个柜子的活，现在需要同时组装多个柜子。这一章的段（操作系统当中的一个概念），就是拓宽业务范围的一个表现。写的汇编语言可以不存放或者说操作一个段的内容，可以操作系统里面多个段的数据。

#### 转移指令的原理 为函数打地基 / CALL 和 RET 指令 函数 / 标志寄存器 if else

具有模块化编程的能力

#### 内中断 / int 指令 / 端口 / 外中断 : OS Level
操作系统层级的一些操作。


#### 直接定址表 / 使用 BIOS 进行键盘输入和磁盘读写
一些技巧，以及实际操作
